#--- Steps to take before implementing this code ---#

# 1 Create an dialogflow account and build your conversation
    # The important parts here are the intents which need to include phrases and actions

#NLP Intent
    #What's NLP?
    {
  "responseId": "a3a335ef-8dc3-45c5-85cd-dde6d86240c3-36cd004f",
  "queryResult": {
    "queryText": "what's nlp",
    "action": "NLP",
    "parameters": {
      "NLP": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "NLP stands for Natural-Language Programming.",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "NLP stands for Natural-Language Programming."
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/f429d003-f4c1-4e10-acfc-be46b6d673bd",
      "displayName": "NLP"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}
   
  #What is NLP? 
   {
  "responseId": "e388dd88-6fce-4e31-9bbe-7c1d263abca2-36cd004f",
  "queryResult": {
    "queryText": "what is nlp",
    "action": "NLP",
    "parameters": {
      "NLP": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "pseudoscientific approach to communication",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "pseudoscientific approach to communication"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/f429d003-f4c1-4e10-acfc-be46b6d673bd",
      "displayName": "NLP"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
} 


   #Can you tell me about NLP?  
    {
  "responseId": "2c169de6-e34f-4498-ab44-45ca8024229a-36cd004f",
  "queryResult": {
    "queryText": "can you tell me about nlp",
    "action": "NLP",
    "parameters": {
      "NLP": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "artificial intelligence concerned with the interactions between computers and human languages",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "artificial intelligence concerned with the interactions between computers and human languages"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/f429d003-f4c1-4e10-acfc-be46b6d673bd",
      "displayName": "NLP"
    },
    "intentDetectionConfidence": 0.7405593,
    "languageCode": "en"
  }
}

#What does NLP stand for? 
    {
  "responseId": "4d912afc-1e06-4aa7-aacf-3de240f8ecff-36cd004f",
  "queryResult": {
    "queryText": "what does nlp stand for",
    "action": "NLP",
    "parameters": {
      "NLP": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "Natural language processing (NLP) is a subfield of linguistics, computer science, information engineering, and artificial intelligence concerned with the interactions between computers and human (natural) languages, in particular how to program computers to process and analyze large amounts of natural language data.\nChallenges in natural language processing frequently involve speech recognition, natural language understanding, and natural language generation.",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "Natural language processing (NLP) is a subfield of linguistics, computer science, information engineering, and artificial intelligence concerned with the interactions between computers and human (natural) languages, in particular how to program computers to process and analyze large amounts of natural language data.\nChallenges in natural language processing frequently involve speech recognition, natural language understanding, and natural language generation."
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/f429d003-f4c1-4e10-acfc-be46b6d673bd",
      "displayName": "NLP"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}
    
#spaCy Intent
    #What is spacy?
    {
  "responseId": "007fce67-99fa-4bdb-beef-2a2f0e58fcdf-36cd004f",
  "queryResult": {
    "queryText": "what is spacy",
    "parameters": {
      "unit-information-name": "spaCy"
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "open-source library",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "open-source library"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/5f860b2f-594b-488c-9ffb-1cbfb5e2c670",
      "displayName": "spaCy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What does spacy do?
{
  "responseId": "e8e85721-b9b5-45b8-b269-dc0e6725b16a-36cd004f",
  "queryResult": {
    "queryText": "what does spacy do",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "focuses on providing software for production usage.",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "focuses on providing software for production usage."
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/5f860b2f-594b-488c-9ffb-1cbfb5e2c670",
      "displayName": "spaCy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What's spacy?
{
  "responseId": "ac1c7891-bbe6-4511-b54e-595149322133-36cd004f",
  "queryResult": {
    "queryText": "what's spacy",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "spaCy is a free open-source library for Natural Language Processing in Python",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "spaCy is a free open-source library for Natural Language Processing in Python"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/5f860b2f-594b-488c-9ffb-1cbfb5e2c670",
      "displayName": "spaCy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What is spacy used for?
{
  "responseId": "8da0a095-03e9-4218-938c-21ae1bcfbffa-36cd004f",
  "queryResult": {
    "queryText": "what is spacy used for",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "spaCy is designed specifically for production use and helps you build applications that process and “understand” large volumes of text. It can be used to build information extraction or natural language understanding systems, or to pre-process text for deep learning.",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "spaCy is designed specifically for production use and helps you build applications that process and “understand” large volumes of text. It can be used to build information extraction or natural language understanding systems, or to pre-process text for deep learning."
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/5f860b2f-594b-488c-9ffb-1cbfb5e2c670",
      "displayName": "spaCy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#textacy Intent
    #What's textacy?
    {
  "responseId": "f77cd138-af38-40bf-8afe-3cc8464f3e34-36cd004f",
  "queryResult": {
    "queryText": "what's textacy",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "textacy is a Python library for performing a variety of natural language processing (NLP) tasks, built on the high-performance spacy library. With the fundamentals – tokenization, part-of-speech tagging, dependency parsing, etc. – delegated to another library, textacy focuses on the tasks that come before and follow after.",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "textacy is a Python library for performing a variety of natural language processing (NLP) tasks, built on the high-performance spacy library. With the fundamentals – tokenization, part-of-speech tagging, dependency parsing, etc. – delegated to another library, textacy focuses on the tasks that come before and follow after."
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/cc16337b-da47-42e7-a617-3c6ed571a99b",
      "displayName": "textacy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What is textacy used for?
{
  "responseId": "b4b2e535-70f0-49a1-85ac-68c9bc400afb-36cd004f",
  "queryResult": {
    "queryText": "what is textacy used for",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "Access and filter basic linguistic elements, such as words and ngrams, noun chunks and sentences",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "Access and filter basic linguistic elements, such as words and ngrams, noun chunks and sentences"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/cc16337b-da47-42e7-a617-3c6ed571a99b",
      "displayName": "textacy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What is textacy?
{
  "responseId": "b5edb470-abb4-4417-b178-1136a9cc84e9-36cd004f",
  "queryResult": {
    "queryText": "what is textacy",
    "parameters": {
      "unit-information-name": "textacy"
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "Python library",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "Python library"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/cc16337b-da47-42e7-a617-3c6ed571a99b",
      "displayName": "textacy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#What is textacy used for?
{
  "responseId": "2ad9880b-ee69-4235-94ef-6e66e336aca3-36cd004f",
  "queryResult": {
    "queryText": "what is textacy used for",
    "parameters": {
      "unit-information-name": ""
    },
    "allRequiredParamsPresent": true,
    "fulfillmentText": "Clean and normalize raw text, before analyzing it",
    "fulfillmentMessages": [
      {
        "text": {
          "text": [
            "Clean and normalize raw text, before analyzing it"
          ]
        }
      }
    ],
    "intent": {
      "name": "projects/breli-mowotx/agent/intents/cc16337b-da47-42e7-a617-3c6ed571a99b",
      "displayName": "textacy"
    },
    "intentDetectionConfidence": 1,
    "languageCode": "en"
  }
}

#--- Platforms used ---#

# 1 Heroku - free plan https://www.heroku.com/

#--- End of platforms used ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
#--- Imports ---#
# Throughout this program we call the below imports for various actions
# failing to import one of these libraries, or importing the wrong one
# may be one reason for an app just failing mid-process


# All of these libraries need to be reflected in our requirements file
# which we upload as part of our app


import os
from flask import Flask, make_response, request
import json

import os.path
import sys

import requests


try:
    import dialogflow
except ImportError:
    sys.path.append(
        os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
    import dialogflow

from collections import Counter


import psycopg2
from flask.ext.sqlalchemy import SQLAlchemy
#Thanks to http://blog.y3xz.com/blog/2012/08/16/flask-and-postgresql-on-heroku

import urllib.parse
#Thanks to https://stackoverflow.com/questions/45133831/heroku-cant-launch-python-flask-app-attributeerror-function-object-has-no

import tasks

app = Flask(__name__)

#--- End of imports ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#

#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- Confirming asynchronous process is working ---#
# This is run when we are first starting up our application.
# It allows us to make sure that our asynchronous worker process
# is receiving commands correctly

tasks.add("startup", " testing task ",1, 2)

#--- End of confirming asynchronous process is working ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#Database variables
#
# These variables are instructions to allow our program to connect to the
# database we set up
# instructions for how to create environment variables in Heroku are at (https://devcenter.heroku.com/articles/config-vars)
# setting database variables: http://blog.y3xz.com/blog/2012/08/16/flask-and-postgresql-on-heroku
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ['DATABASE_URL']
db = SQLAlchemy(app)

@app.route('/', methods=["GET", "POST"])
def webhook():

    #------------------------------------------------------------#
    # Setting location codes, these will be used in print commands
    # so we can easily keep track of where things are. The only
    # purpose of these is to be included in the print commands
    # however if they are removed the app will break at the first
    # print
    #------------------------------------------------------------#
    app_code="web "
    location_code="1 (startup)"
    #------------------------------------------------------------#
    # End of setting location codes
    #------------------------------------------------------------#

    #------------------------------------------------------------#
    # Printing initial startup information, sharing the request
    # that activated the app_code
    #------------------------------------------------------------#
    print (app_code,location_code, "starting at ", datetime.utcnow())
    print(app_code,location_code, "request", request)
    print(app_code,location_code, "request method", request.method)
    #------------------------------------------------------------#
    # End of printing initial startup info
    #------------------------------------------------------------#


#--- End of start application ---#

#
#--- C Setting up psycopg2 connection ---#
# Thanks to: https://devcenter.heroku.com/articles/heroku-postgresql#connecting-in-python

def open_db_connection(app_code,location_code):
    sublocation="C (open_db_connection) - "
    print (app_code,location_code,sublocation," starting setting up database connection")
    #Thanks to https://stackoverflow.com/questions/45133831/heroku-cant-launch-python-flask-app-attributeerror-function-object-has-no
    urllib.parse.uses_netloc.append("postgres")
    url = urllib.parse.urlparse(os.environ["DATABASE_URL"])
    #}
    print (app_code,location_code,sublocation," url: ", url)

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Setting conn as a global variable ---#

    # We are setting conn as a global variable which means it doesn't
    # have to be included when we call a new function, we will be referencing
    # it in a few functions so it's important to be able to access it
    # without causing errors by forgetting to include it from one function to the next
    global conn

    conn = psycopg2.connect(
        database=url.path[1:],
        user=url.username,
        password=url.password,
        host=url.hostname,
        port=url.port
    )



    #--- End of Setting conn as a global variable ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Setting cur as a global variable ---#

    # See reasoning for including conn as global variable above
    global cur
    cur = conn.cursor()

    #--- End of Setting cur as a global variable ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    print (app_code,location_code,sublocation," finishing setting up database connection")

    return

#--- End of Web Setting up psycopg2 connection ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#

#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- D Web closing psycopg2 connection ---#

def close_db_connection(app_code,location_code):
        sublocation="D (close_db_connection) - "

        print (app_code,location_code,sublocation," starting connection shut down")

        #Closing connection with database
        cur.close()
        print (app_code,location_code,sublocation," closed cursor")
        conn.close()
        print (app_code,location_code,sublocation," closed connection")

        print (app_code,location_code,sublocation," finished connection shut down")
        return


#--- D End of Web closing connection with database ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#

#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- E Web creating user  ---#


def user_creator(app_code,location_code,source, user_id, user_token, bot_token, team_id, team_name):

    sublocation="E (user_creator)"

    print (app_code,location_code,sublocation," creating user process")
    print (app_code,location_code,sublocation, " source: ", source, " user_id: ", user_id, " user_token: ", user_token, " bot_token: ", bot_token," team_id: ", team_id," team_name: ", team_name)

    #--- Web creating user ---#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Listing all table names as part of debug ---#

    print (app_code,location_code,sublocation," trying to fetch all tables")
    cur.execute("""SELECT table_name FROM information_schema.tables
    WHERE table_schema = 'public'""")
    for table in cur.fetchall():
        print (app_code,location_code,sublocation,table)

    #--- End of Listing all table names as part of debug ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Listing all column names as part of debug ---#

    # Fetching all column names in named table, as part of debugging process
    print (app_code,location_code,sublocation,"success, trying to fetch all rows in users_and_actions")
    cur.execute("SELECT * FROM users_and_actions LIMIT 0")
    print (app_code,location_code,sublocation," successful fetch")
    colnames = [desc[0] for desc in cur.description]
    print (app_code,location_code,sublocation," columns in table are: ", colnames)

    #--- End of Listing all column names as part of debug ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Checking if user already exists ---#

    cur.execute("SELECT user_token FROM users_and_actions WHERE user_id = %(uid)s",{"uid": user_id})
    existing_token=cur.fetchone()

    print (app_code,location_code,sublocation," existing_token is ", existing_token)



    if existing_token!=None:
        # If user is not None, then it exists and we shouldn't repeat the creation process
        print (app_code,location_code,sublocation," user already created")
        cur.execute("SELECT * FROM users_and_actions WHERE user_id = %(uid)s",
                   {"uid": user_id})
        print (app_code,location_code,sublocation," web user_creator - fetching one result: ", cur.fetchone())
        print (app_code,location_code,sublocation," web user_creator - end of function")
        return

        #--- End of Checking if user already exists ---#
        #
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Adding user ---#

    cur.execute("INSERT INTO users_and_actions (source, user_id, user_token, bot_token, team_id, team_name) VALUES (%s, %s, %s, %s, %s, %s);", (source, user_id, user_token, bot_token, team_id, team_name))

    print (app_code,location_code,sublocation," added ", user_id, " to users_and_actions")
    #Saving the data to the table
    conn.commit()
    print (app_code,location_code,sublocation," committed ",user_id," data")

    #--- End of Adding user ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Checking user record just added ---#

    #A process for retrieving records (thanks to https://stackoverflow.com/questions/1466741/parameterized-queries-with-psycopg2-python-db-api-and-postgresql)
    print (app_code,location_code,sublocation," recalling ", user_id, " only")
    cur.execute("SELECT user_id FROM users_and_actions WHERE user_id = %(uid)s",
               {"uid": user_id})
    print (app_code,location_code,sublocation," fetching new user ID: ", cur.fetchone())
    print (app_code,location_code,sublocation," recalling whole record")
    cur.execute("SELECT * FROM users_and_actions WHERE user_id = %(uid)s",
               {"uid": user_id})
    print (app_code,location_code,sublocation," fetching one result: ", cur.fetchone())
    print (app_code,location_code,sublocation," end of function")

    return

    #--- End of Checking user record just added ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


#--- End of Web creating user ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#


#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- F updating columns  ---#


def update_columns(app_code,location_code,list_of_pairs, user_id):
    # Our update_columns process takes information and puts it
    # into our database the first two  arguments are just the application
    # and process portion, to offer more informative printouts within
    # the process. Within the square brackets, we give information
    # in pairs, first the column to update, then the information
    # to put in it, this means if we want to give lots of columns to
    # update we can just pass [column, value, column, value] etc.
    # the final argument is the unique user_id we use to identify
    # which record we're reading and updating from

    sublocation="F (update_columns)"

    print (app_code,location_code,sublocation," starting update_columns process")
    print (app_code,location_code,sublocation," defining column is user_id")
    print (app_code,location_code,sublocation," defining value is: ", user_id)


    #Process for updating records in the database (thanks to https://stackoverflow.com/questions/7458749/psycopg2-insert-update-writing-problem)


    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Retrieving values before change ---#
    print (app_code,location_code,sublocation," retrieving values before change")
    # A process for retrieving records (thanks to https://stackoverflow.com/questions/1466741/parameterized-queries-with-psycopg2-python-db-api-and-postgresql)
    cur.execute("SELECT * FROM users_and_actions WHERE user_id = %s", (user_id,));

    print (app_code,location_code,sublocation," values as they are: ", cur.fetchone())

    #--- End of Retrieving values before change ---#
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Changing values ---#

    #Creating a loop to go through all of the column value pairs that have been passed
    # As an FYI, the name of the table cannot be passed as a parameter, that has to be hard coded (https://stackoverflow.com/questions/13793399/passing-table-name-as-a-parameter-in-psycopg2)

    print (app_code,location_code,sublocation,"splitting list_of_pairs into update_pairs")

    #Process for splitting one list into list of lists (thanks to https://stackoverflow.com/questions/9671224/split-a-python-list-into-other-sublists-i-e-smaller-lists)
    update_pairs = [list_of_pairs[x:x+2] for x in range(0, len(list_of_pairs), 2)]
    print (app_code,location_code,sublocation,"list split into update_pairs")

    #|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
    #
    #--- Looping through pairs to make change ---#

    for pair in update_pairs:
        print (app_code,location_code,sublocation," splitting the column, value pair to acess column and value separately")
        print (app_code,location_code,sublocation," first pair is: ", pair)

        #Selecting the first item of the pair (which should always be the column)
        column=pair[0]
        print (app_code,location_code,sublocation," column to update is ", column)

        #Selecting the second item (which should always be the value)
        values_to_add= pair[1]
        print (app_code,location_code,sublocation," value to add to ", column, " is ", values_to_add)

        # In this part of the for loop - adding the value (thanks to http://initd.org/psycopg/docs/sql.html)
        # IMPORTANT, the only reason we can use string concatenation here (injecting the column value with a plus) is that
        # we are defining the column, user input cannot define what value that is, if users could define the column name
        # this would be at risk of sql injection.

        cur.execute("UPDATE users_and_actions SET "+column+"=%s WHERE user_id=%s", (values_to_add, user_id));

        # getting the number of updated rows
        updated_rows = cur.rowcount
        print (app_code,location_code,sublocation," number of rows updated = ", updated_rows)
        conn.commit()
        print (app_code,location_code,sublocation," committed data")
        print (app_code,location_code,sublocation," executed change, updated users_and_actions column: ", column, "to be ", values_to_add ," where user_id is ", user_id)
        cur.execute("SELECT "+ column +" FROM users_and_actions WHERE user_id= %s", (user_id,));
        print(app_code,location_code,sublocation," value after most recent change: ", cur.fetchone())

        #--- End of Looping through pairs to make change ---#
        #
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

        #--- End of Changing values ---#
        #
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


    print(app_code,location_code,sublocation," retrieving values after change")
    cur.execute("SELECT * FROM users_and_actions WHERE user_id= %s", (user_id,));
    print(app_code,location_code,sublocation," values as they are post change: ", cur.fetchone())
    print(app_code,location_code,sublocation," end of function")

    print(app_code,location_code,sublocation," ending update_columns process")

    return

#--- End of F updating columns  ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#

#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- G checking database for a value  ---#

def check_database(app_code,location_code,user_id, column):
    # This takes a user_id and a column and returns the
    # column value where that user_id exists, the app_code
    # and location_code are just for print functions

    sublocation="G (check_database)"

    print (app_code,location_code,sublocation,"starting check_database process, user_id is: ", user_id)

    # A process for retrieving records (thanks to https://stackoverflow.com/questions/1466741/parameterized-queries-with-psycopg2-python-db-api-and-postgresql)
    # IMPORTANT, the only reason we can use string concatenation here (injecting the column value with a plus) is that
    # we are defining the column, user input cannot define what value that is, if users could define the column name
    # this would be at risk of sql injection.
    cur.execute("SELECT "+column+" FROM users_and_actions WHERE user_id = %(current_uid)s",{"current_uid": user_id})
    value=cur.fetchone()

    print (app_code,location_code,sublocation," ending check_database process")

    for item in value:
        # Unpacking items (thanks to https://stackoverflow.com/questions/34178172/psycopg2-selecting-timestamp-returns-datetime-datetime-wrapped-in-tuple-how-to)\
        item_to_use=item

    print (app_code,location_code,sublocation," ",column," is: ", item_to_use)

    # Returning the item we have retrieved
    return item_to_use

#--- End of G checking database for a value  ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#

#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- H dealing with interactive button message  ---#
# method for unpacking a message from an interactive button click
# thanks to https://github.com/slackapi/python-message-menu-example/blob/master/example.py

def button_message(app_code,location_code,request):
    sublocation="H (interactive button)"

     # Parse the request payload
    form_json = json.loads(request.form["payload"])

    print (app_code,location_code,sublocation," request is: ", form_json)

    # Check to see what the user's selection was and update the message
    selection=form_json.get('actions')[0].get('value')
    print (app_code,location_code,sublocation," selection is: ", selection)

    user_id=form_json.get('user').get('id')
    print (app_code,location_code,sublocation," user is: ", user_id)

    channel=form_json.get('channel').get('id')
    print (app_code,location_code,sublocation," channel is: ", channel)

    # By making our API.AI intent criteria match button names we can make this flexible for
    # multiple button-types
    query=selection

    event_id="button_push"

    tasks.send_to_api(event_id, user_id, channel, query)

    return


#===========================================================================================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#============================================= End Synchronous functions ===================================================#
#---------------------------------------------------------------------------------------------------------------------------#
#===========================================================================================================================#


#|||||||||||||||||||||||||||||||||||||||||||||||||||||||#
#
#--- Process to activate app ---#

#This is necessary for any function to activate rather than app exiting with code 0

#----------#

if __name__ == '__main__':
    port = int(os.getenv('PORT', 5000))

    print("Starting app on port %d" % port)

    app.run(debug=False, port=port, host='0.0.0.0')


#-----------------------------------#

#--- End of process activating app ---#
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
